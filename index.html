<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<title>3D FPS 高難度槍戰遊戲</title>
<style>
    body { margin: 0; overflow: hidden; cursor: none; }
    #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        padding: 10px;
        background: rgba(0,0,0,0.5);
        color: white;
        font-family: Arial;
        border-radius: 6px;
    }
    /* 準心 */
    #crosshair {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 20px;
        height: 20px;
        margin-left: -10px;
        margin-top: -10px;
    }
    #crosshair:before, #crosshair:after {
        content: '';
        position: absolute;
        background: white;
    }
    #crosshair:before {
        top: 50%;
        left: 0;
        width: 100%;
        height: 2px;
        transform: translateY(-50%);
    }
    #crosshair:after {
        left: 50%;
        top: 0;
        width: 2px;
        height: 100%;
        transform: translateX(-50%);
    }
</style>
</head>
<body>

<div id="ui">
    <b>操作說明</b><br>
    W/A/S/D：移動<br>
    滑鼠：旋轉視角<br>
    左鍵：射擊<br>
    HP: <span id="hp">3</span>
</div>
<div id="crosshair"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
/* ====== 基本場景 ====== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
);
camera.position.set(0, 1.6, 0);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ====== 地板 ====== */
const floor = new THREE.Mesh(
    new THREE.PlaneGeometry(100, 100),
    new THREE.MeshBasicMaterial({ color: 0x228B22 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

/* ====== 玩家 ====== */
const player = { position: new THREE.Vector3(0,0,0) };
let playerHP = 3;
document.getElementById("hp").innerText = playerHP;

/* ====== 控制 ====== */
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

/* ====== 滑鼠視角 ====== */
let pitch = 0, yaw = 0;
document.body.requestPointerLock = document.body.requestPointerLock || document.body.mozRequestPointerLock;
document.body.onclick = ()=>document.body.requestPointerLock();

document.addEventListener('mousemove', e=>{
    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
});

/* ====== 子彈 ====== */
const bullets = [];
function shoot() {
    const b = new THREE.Mesh(
        new THREE.BoxGeometry(0.05,0.05,0.3),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
    );
    const dir = new THREE.Vector3(0,0,-1).applyEuler(new THREE.Euler(pitch, yaw, 0));
    b.position.copy(camera.position);
    b.userData.dir = dir;
    bullets.push(b);
    scene.add(b);
}
window.addEventListener('mousedown', e => { if(e.button===0) shoot(); });

/* ====== 敵人 ====== */
const enemies = [];
let gameTime = 0;

function createEnemy() {
    const type = Math.random() < 0.3 ? 'fast' : 'normal';
    const g = new THREE.Mesh(
        new THREE.BoxGeometry(0.5,1.2,0.4),
        new THREE.MeshBasicMaterial({ color: type==='fast'?0xff8800:0xff0000 })
    );
    g.position.set((Math.random()-0.5)*20,0,-30);
    g.userData = { type };
    enemies.push(g);
    scene.add(g);
}

// 每秒生成兩個敵人
setInterval(()=>{
    createEnemy();
    createEnemy();
    gameTime += 1;
}, 1000);

/* ====== 動畫 ====== */
function animate() {
    requestAnimationFrame(animate);

    // 玩家移動
    const speed = 0.1;
    const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
    const right = new THREE.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2));

    if(keys.KeyW) player.position.add(forward.clone().multiplyScalar(speed));
    if(keys.KeyS) player.position.add(forward.clone().multiplyScalar(-speed));
    if(keys.KeyA) player.position.add(right.clone().multiplyScalar(-speed));
    if(keys.KeyD) player.position.add(right.clone().multiplyScalar(speed));

    camera.position.copy(player.position).add(new THREE.Vector3(0,1.6,0));
    camera.rotation.set(pitch,yaw,0);

    // 子彈
    bullets.forEach((b,i)=>{
        b.position.add(b.userData.dir.clone().multiplyScalar(0.5));
        if(b.position.distanceTo(player.position) > 50){
            scene.remove(b);
            bullets.splice(i,1);
        }
    });

    // 敵人追蹤玩家
    enemies.forEach((e,ei)=>{
        const dir = new THREE.Vector3().subVectors(player.position,e.position).normalize();
        const baseSpeed = e.userData.type==='fast'?0.04:0.02;
        const speed = baseSpeed + gameTime*0.001; // 隨時間加快
        e.position.add(dir.multiplyScalar(speed));

        // 玩家碰撞
        if(e.position.distanceTo(player.position) < 0.7){
            playerHP--;
            document.getElementById("hp").innerText = playerHP;
            scene.remove(e);
            enemies.splice(ei,1);
            if(playerHP <=0) alert("遊戲結束");
        }

        // 子彈碰撞
        bullets.forEach((b,bi)=>{
            if(b.position.distanceTo(e.position) < 0.5){
                scene.remove(e);
                scene.remove(b);
                enemies.splice(ei,1);
                bullets.splice(bi,1);
            }
        });
    });

    renderer.render(scene,camera);
}
animate();

/* ====== 視窗調整 ====== */
window.addEventListener('resize', ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
